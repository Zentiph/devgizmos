# pylint: disable=all

from abc import ABC, abstractmethod
from types import TracebackType
from typing import (
    Any,
    Callable,
    Dict,
    Iterator,
    List,
    Optional,
    Self,
    Tuple,
    Type,
    TypeVar,
    Union,
)

F = TypeVar("F", bound=Callable[..., Any])

class UnsupportedOSError(Exception): ...

class Retry:
    def __init__(
        self,
        max_attempts: int,
        delay: Union[int, float],
        backoff_strategy: Optional[
            Callable[[Union[int, float], int], Union[int, float]]
        ] = None,
        exceptions: Tuple[Type[BaseException]] = (Exception,),
        raise_last: bool = True,
    ): ...
    def __call__(self, func: F, /) -> F: ...
    @property
    def max_attempts(self) -> int: ...
    @max_attempts.setter
    def max_attempts(self, m: int, /) -> None: ...
    @property
    def delay(self) -> Union[int, float]: ...
    @delay.setter
    def delay(self, d: Union[int, float], /) -> None: ...
    @property
    def backoff_strategy(
        self,
    ) -> Union[Callable[[Union[int, float], int], Union[int, float]], None]: ...
    @backoff_strategy.setter
    def backoff_strategy(
        self, bs: Optional[Callable[[Union[int, float], int], Union[int, float]]], /
    ) -> None: ...
    @property
    def exceptions(self) -> Tuple[Type[BaseException], ...]: ...
    @exceptions.setter
    def exceptions(self, excs: Tuple[Type[BaseException], ...], /) -> None: ...
    @property
    def raise_last(self) -> bool: ...
    @raise_last.setter
    def raise_last(self, rl: bool, /) -> None: ...
    @property
    def attempts(self) -> int: ...
    @property
    def caught(self) -> List[Type[BaseException]]: ...

class Timeout:
    def __init__(
        self,
        cutoff: Union[int, float],
        exc: Optional[Type[BaseException]] = TimeoutError,
    ) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[TracebackType],
    ) -> None: ...
    def __call__(self, func: F, /) -> F: ...
    @property
    def cutoff(self) -> Union[int, float]: ...
    @property
    def exc(self) -> Type[BaseException]: ...
    @exc.setter
    def exc(self, e: Type[BaseException], /) -> None: ...

class FailureHandler(ABC):
    @abstractmethod
    def __init__(self, *args, **kwargs) -> None: ...
    @abstractmethod
    def __call__(self) -> None: ...
    @property
    def priority(self) -> int: ...
    @priority.setter
    def priority(self, p: int, /) -> None: ...
    @property
    def returned(self) -> Any: ...
    @property
    def suppress(self) -> bool: ...
    @suppress.setter
    def suppress(self, s: bool) -> None: ...
    @abstractmethod
    def __str__(self) -> str: ...
    @abstractmethod
    def __repr__(self) -> str: ...

class Fallback(FailureHandler):
    def __init__(
        self, func: Callable[..., Any], *args: Any, **kwargs: Dict[str, Any]
    ) -> None: ...
    def __call__(self) -> None: ...
    def validate(self) -> bool: ...
    def error_scan(self) -> Union[Type[Exception], None]: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

class _HandlerCollection:
    def __init__(self, *handlers: Optional[FailureHandler]) -> None: ...
    @property
    def priorities(self) -> Tuple[int, ...]: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> FailureHandler: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

class FailureManager:
    def __init__(
        self,
        *handlers: Optional[FailureHandler],
        exceptions: Tuple[Type[BaseException]] = (Exception,),
    ) -> None: ...
    def __enter__(self) -> Self: ...
    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[TracebackType],
    ) -> None: ...
    def __call__(self, func: F, /) -> F: ...
    def sort_handler_priorities(self) -> None: ...
    def set_priority(self, handler: FailureHandler, priority: int, /) -> None: ...
    def add_handler(self, handler: FailureHandler, /) -> None: ...
    def del_handler(self, priority: int, /) -> None: ...
    @property
    def handlers(self) -> _HandlerCollection: ...
    @property
    def exceptions(self) -> Tuple[Type[BaseException], ...]: ...
    @exceptions.setter
    def exceptions(self, excs: Tuple[Type[BaseException], ...]) -> None: ...
    @property
    def caught(
        self,
    ) -> List[Tuple[Type[BaseException], BaseException, TracebackType]]: ...
